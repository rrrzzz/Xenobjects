using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using UnityEngine;


namespace SplineMesh 
{
    /// <summary>
    /// Deform a mesh and place it along a spline, given various parameters.
    /// 
    /// This class intend to cover the most common situations of mesh bending. It can be used as-is in your project,
    /// or can serve as a source of inspiration to write your own procedural generator.
    /// </summary>
    [ExecuteAlways]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineMeshTiling : MonoBehaviour 
    {
        private GameObject generated;
        private Spline spline;
        private bool toUpdate;

        [Tooltip("Mesh to bend along the spline.")]
        public Mesh mesh;
        [Tooltip("Material to apply on the bent mesh.")]
        public Material material;
        [Tooltip("Translation to apply on the mesh before bending it.")]
        public Vector3 translation;
        [Tooltip("Rotation to apply on the mesh before bending it.")]
        public Vector3 rotation;
        [Tooltip("Scale to apply on the mesh before bending it.")]
        public Vector3 scale = Vector3.one;

        // public int startNodeIdx;
        // public float startScale = 2.65f;
        // public float endScale = 0.05f;
        
        public AnimationCurve scaleCurve;
        public bool killTween;
        public bool scaleToZero;
        public float scaleDuration = 2;
        // public float interpolationDuration;
        public bool resetScalingAndTime;
        public bool scaleToFull;
        public bool saveScales;
        public int nodesAffected;
        public float delayInterval = 0.01f;
        // public bool interpolatePositionDir;
        
        private bool _isScalesSaved;
        private List<Vector2> _initialScales = new List<Vector2>();
        private Vector3 _nodeStartPos = new Vector3(3.985474f, 5.676583f, -11.20474f);
        private Vector3 _nodeEndPos = new Vector3(3.985474f, 5.676583f, -6.954725f);
        private Vector3 _nodeStartDir = new Vector3(3.921951f, 5.766486f, -10.64462f);
        private Vector3 _nodeEndDir = new Vector3(3.921951f, 5.766486f, -6.509478f);

        private void OnEnable()
        {
            // tip : if you name all generated content in the same way, you can easily find all of it
            // at once in the scene view, with a single search.
            string generatedName = "generated by " + GetType().Name;
            var generatedTransform = transform.Find(generatedName);
            generated = generatedTransform ? generatedTransform.gameObject : UOUtility.Create(generatedName, gameObject);

            spline = GetComponentInParent<Spline>();
            spline.NodeListChanged += (_, _) => toUpdate = true;
            
            _nodeStartPos = spline.nodes[0].Position;
            _nodeStartDir = spline.nodes[0].Direction;
            _nodeEndPos = spline.nodes[1].Position;
            _nodeEndDir = spline.nodes[1].Direction;

            toUpdate = true;
            _initialScales.Clear();
            
            foreach (var n in spline.nodes)
            {
                if (Mathf.Approximately(n.Scale.x, 0))
                {
                    continue;
                }
                _initialScales.Add(n.Scale);
            }
            saveScales = false; 
        }

        private void OnValidate() 
        {
            if (!spline) return;
            toUpdate = true;
        }

        private void Update() 
        {
            if (killTween)
            {
                DOTween.Kill(1488);
                killTween = false;
            }

            if (saveScales || _initialScales.Count == 0)
            {
                saveScales = false;
                _initialScales.Clear();
                foreach (var n in spline.nodes)
                {
                    _initialScales.Add(n.Scale);
                }
            }
            
            if (toUpdate) 
            {
                toUpdate = false;
                CreateMeshes();
            }

            if (resetScalingAndTime)
            {
                resetScalingAndTime = false;

                if (!_isScalesSaved)
                {
                    _isScalesSaved = true;
                    _initialScales.Clear();
                    foreach (var n in spline.nodes)
                    {
                        _initialScales.Add(n.Scale);
                    }
                }
                
                spline.nodes[0].Position = _nodeStartPos;
                spline.nodes[0].Direction = _nodeStartDir;

                for (int i = 0; i < _initialScales.Count; i++)
                {
                    spline.nodes[i].Scale = _initialScales[i];
                }
            }

            if (scaleToFull || scaleToZero)
            {
                ScaleSpline();
            }

            // if (interpolatePositionDir)
            // {
            //     if (!_startedThings)
            //     {
            //         _startTime = Time.realtimeSinceStartup;
            //         _startedThings = true;
            //         _nodeStartPos = spline.nodes[0].Position;
            //         _nodeStartDir = spline.nodes[0].Direction;
            //         _nodeEndPos = spline.nodes[1].Position;
            //         _nodeEndDir = spline.nodes[1].Direction;
            //     }
            //     
            //     var elapsedTime = Time.realtimeSinceStartup - _startTime;
            //     float t = elapsedTime / scaleDuration;
            //     var node = spline.nodes[0];
            //     node.Position = Vector3.Lerp(_nodeStartPos, _nodeEndPos, t);
            //     node.Direction = Vector3.Lerp(_nodeStartDir, _nodeEndDir, t);
            // }
        }

        void KillTween()
        {
            DOTween.Kill(1488);
        }
        
        private void ScaleSpline()
        {
            DOTween.Kill(1488);
                
            for (int i = 0; i < spline.nodes.Count; i++)
            {
                if (!scaleToZero)
                {
                    spline.nodes[i].Scale = Vector2.zero;
                }
            }
                
            for (int i = 0; i < spline.nodes.Count; i++)
            {
                if (i > nodesAffected && nodesAffected != 0)
                {
                    break;
                }
                    
                var i1 = i;
                if (scaleToZero)
                {
                    DOTween.To(() => spline.nodes[i1].Scale, x => spline.nodes[i1].Scale = x, Vector2.zero,
                            scaleDuration)
                        .SetEase(scaleCurve).SetDelay(delayInterval * i).SetId(1488);
                }
                else
                {
                    DOTween.To(() => spline.nodes[i1].Scale, x => spline.nodes[i1].Scale = x, _initialScales[i1],
                            scaleDuration)
                        .SetEase(scaleCurve).SetDelay(delayInterval * i).SetId(1488);
                }
                // DOVirtual.DelayedCall(killDelay, () => KillTween());
            }
            scaleToFull = scaleToZero = false;

            // if (interpolatePositionDir)
            // {
            //     float tInterpol = Mathf.Clamp(elapsedTime / interpolationDuration, 0, 0.5f);
            //
            //     var node = spline.nodes[0];
            //     node.Position = Vector3.Lerp(_nodeStartPos, _nodeEndPos, tInterpol);
            //     node.Direction = Vector3.Lerp(_nodeStartDir, _nodeEndDir, tInterpol);
            // }
        }

        private void CreateMeshes() 
        {
#if UNITY_EDITOR
            // we don't update if we are in prefab mode
            if (UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage()) return;
#endif
            var used = new List<GameObject>();

            
            int i = 0;
            foreach (var curve in spline.curves) 
            {
                var go = FindOrCreate("segment " + i++ + " mesh");
                go.GetComponent<MeshBender>().SetInterval(curve);
                used.Add(go);
            }

            // we destroy the unused objects. This is classic pooling to recycle game objects.
            foreach (var go in generated.transform
                .Cast<Transform>()
                .Select(child => child.gameObject).Except(used).ToList()) 
            {
                UOUtility.Destroy(go);
            }
        }

        private GameObject FindOrCreate(string goName) 
        {
            var childTransform = generated.transform.Find(goName);
            GameObject res;
            if (!childTransform) 
            {
                res = UOUtility.Create(goName,
                    generated,
                    typeof(MeshFilter),
                    typeof(MeshRenderer),
                    typeof(MeshBender));
                res.isStatic = false;
            } 
            else 
            {
                res = childTransform.gameObject;
            }
            
            var meshRenderer = res.GetComponent<MeshRenderer>();
            meshRenderer.material = material;
            MeshBender mb = res.GetComponent<MeshBender>();
           
            mb.Source = SourceMesh.Build(mesh)
                .Translate(translation)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            mb.Mode = MeshBender.FillingMode.StretchToInterval;
            return res;
        }
        
        // private void ScaleSegment()
        // {
        //     if (!_startedThings)
        //     {
        //         _segmentsScales[0] = Vector2.one * startScale;
        //         _segmentsScales[1] = Vector2.one * ((startScale + endScale) / 2);
        //         _segmentsScales[2] = Vector2.one * endScale;
        //         _startedThings = true;
        //         _startTime = Time.realtimeSinceStartup;
        //     }
        //     
        //     var elapsedTime = Time.realtimeSinceStartup - _startTime;
        //
        //     var ts = new float[spline.nodes.Count];
        //
        //     for (int i = startNodeIdx; i < startNodeIdx + 3; i++)
        //     {
        //         var t = elapsedTime / scaleDuration;
        //
        //         if (i > startNodeIdx && ts[i - 1] > tThreshold)
        //         {
        //             t = ts[i - 1] - tThreshold;
        //             ts[i] = t;
        //         }
        //         else if (i > startNodeIdx && ts[i - 1] < tThreshold)
        //         {
        //             t = 0;
        //         }
        //         
        //         ts[i] = t;
        //
        //         if (scaleToZero && i != 2)
        //         {
        //             spline.nodes[i].Scale = Vector2.Lerp(Vector2.one * _segmentsScales[i - startNodeIdx], Vector2.zero, t);
        //         }
        //         else
        //         {
        //             spline.nodes[i].Scale = Vector2.Lerp(Vector2.zero, _segmentsScales[i - startNodeIdx], t);
        //         }
        //     }
        // }
    }
}
