using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using EasyButtons;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;
using Quaternion = UnityEngine.Quaternion;
using Vector2 = UnityEngine.Vector2;
using Vector3 = UnityEngine.Vector3;


namespace SplineMesh 
{
    /// <summary>
    /// Deform a mesh and place it along a spline, given various parameters.
    /// 
    /// This class intend to cover the most common situations of mesh bending. It can be used as-is in your project,
    /// or can serve as a source of inspiration to write your own procedural generator.
    /// </summary>
    [ExecuteAlways]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineMeshTiling : MonoBehaviour 
    {
        [Tooltip("Mesh to bend along the spline.")]
        public Mesh mesh;
        [Tooltip("Material to apply on the bent mesh.")]
        public Material material;
        [Tooltip("Translation to apply on the mesh before bending it.")]
        public Vector3 translation;
        [Tooltip("Rotation to apply on the mesh before bending it.")]
        public Vector3 rotation;
        [Tooltip("Scale to apply on the mesh before bending it.")]
        public Vector3 scale = Vector3.one;
        
        // public int startNodeIdx;
        // public float startScale = 2.65f;
        // public float endScale = 0.05f;

        public bool scaleToZeroOnInit = true;
        public bool isCreatingEnabled = true;
        public float centerBoxSize;
        public float vanishingScaleThreshold;
        public float scaleToFullDuration = 1;
        public float scaleToZeroDuration = 1;
        public float vanishingDuration = 1;
        public float scaleToFullDelay = 0.1f;
        public float scaleToZeroDelay = 0.1f;
        public float vanishingDelay = 0.1f;
        [FormerlySerializedAs("scaleToFullCurve")]
        public AnimationCurve scaleCurve;
        public AnimationCurve vanishingCurve;
        public float interpolationDuration;
        public List<Vector2> initialScales = new List<Vector2>();
        
        public UnityEvent PathEndReachedEvent { get; } = new UnityEvent();

        private GameObject _generated;
        private Spline _spline;
        private bool _toUpdate;
        
        private Vector3 _orbScale;
        private bool _isScalesSaved;
        private bool _isMinusNodePosNudge;
        private bool _isVanishing;
        private bool _isVanishingByDistance;
        private int _currentNodeToReach;
        private Transform _playerTr;
        private float _playerToPathNodeDistanceThreshold;
        private Transform[] _segmentTransforms;
        private readonly Vector3 _endPos = new Vector3(7.53f, -16.57f, -23.33f);
        private readonly Vector3 _endDir = new Vector3(29.07f, -8.01f, -11.87f);
        
        private void OnEnable()
        {
            string generatedName = "generated by " + GetType().Name;
            var generatedTransform = transform.Find(generatedName);

            _generated = generatedTransform ? generatedTransform.gameObject : UOUtility.Create(generatedName, gameObject);
            _spline = GetComponentInParent<Spline>();
            _spline.NodeListChanged += (_, _) => _toUpdate = true;

            _segmentTransforms = GetComponentsInChildren<MeshRenderer>().Select(x => x.transform).ToArray();
            _toUpdate = true;

            if (scaleToZeroOnInit)
                ScaleToZeroNow();
        }

        
        [Button]
        private void PrintPosRot()
        {
            print(_spline.nodes[0].Position);
            print(_spline.nodes[0].Direction);
        }
        
        private void OnValidate() 
        {
            if (!_spline) return;
            _toUpdate = true;
        }

        [Button]
        public void ToggleTween()
        {
            DOTween.TogglePause(1488);
        }
        
        private void Update()
        {
            if (_isVanishingByDistance)
            {
                ResumeVanishingIfCloseToCurrentNode();
            }
            
            if (_isVanishing)
            {
                var currentScale = _spline.nodes[_currentNodeToReach].Scale.x;
                if (currentScale < vanishingScaleThreshold)
                {
                    DOTween.TogglePause(1488);
                    _isVanishing = false;
                }
            }
            
            if (!_toUpdate) return;
            
            _toUpdate = false;
            CreateMeshes();
        }
        
        private void ResumeVanishingIfCloseToCurrentNode()
        {
            var globalPos = GetGlobalNodePos(_currentNodeToReach);
            var distanceToNode = Vector3.Distance(globalPos, _playerTr.position);

            if (distanceToNode < _playerToPathNodeDistanceThreshold && !_isVanishing)
            {
                DOTween.TogglePause(1488);
                _currentNodeToReach++;
                if (_currentNodeToReach == _spline.nodes.Count)
                {
                    _isVanishingByDistance = false;
                    PathEndReachedEvent.Invoke();
                    return;
                }
                _isVanishing = true;
            }
        } 
        
        [Button]
        private void SetAllNodeControlsToMirrored()
        {
            foreach (var node in _spline.nodes)
            {
                node.directionType = SplineNode.TangentType.Mirrored;
                node.Position += new Vector3(0, _isMinusNodePosNudge ? -0.001f : 0.001f, 0);
            }

            _isMinusNodePosNudge = !_isMinusNodePosNudge;
        }
        
        [Button]
        public void ScaleToFullNow()
        {
            for (int i = 0; i < _spline.nodes.Count; i++)
            {
                _spline.nodes[i].Scale = initialScales[i];
            }
        }
        
        [Button]
        public void ScaleToFull()
        {
            ScaleSpline(true);
        }
        
        [Button]
        public void ScaleToZeroNow()
        {
            foreach (var node in _spline.nodes)
            {
                node.Scale = Vector2.zero;
            }
        }
        
        [Button]
        public void ScaleToZero()
        {
            ScaleSpline(false);
        }
        
        public float GetTotalVanishingDuration()
        {
            return vanishingDuration + vanishingDelay * _spline.nodes.Count;
        }

        public float GetTotalScaleToFullDuration()
        {
            return scaleToFullDuration + scaleToFullDelay * _spline.nodes.Count;
        }
        
        public float GetTotalScaleToZeroDuration()
        {
            return scaleToZeroDuration + scaleToFullDelay * _spline.nodes.Count;
        }
        
        public void ScaleSpline(bool scaleToFull)
        {
            foreach (var t in _spline.nodes)
            {
                if (scaleToFull)
                {
                    t.Scale = Vector2.zero;
                }
            }
            
            for (int i = 0; i < _spline.nodes.Count; i++)
            {
                var i1 = i;
                
                if (scaleToFull)
                {
                    DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, initialScales[i1],
                        scaleToFullDuration).SetEase(scaleCurve).SetDelay(scaleToFullDelay * i).SetId(1488); 
                }
                else
                {
                    {
                        DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, Vector2.zero,
                                scaleToZeroDuration)
                            .SetEase(scaleCurve).SetDelay(scaleToZeroDelay * i).SetId(1488);
                    }
                }
            }
        }

        // [Button]
        public void InitVanishing(Transform playerTransform, float playerToPathNodeDistanceThreshold)
        {
            _playerTr = playerTransform;
            _playerToPathNodeDistanceThreshold = playerToPathNodeDistanceThreshold;
            _currentNodeToReach = 0;

            for (int i = 0; i < _spline.nodes.Count; i++)
            {
                var i1 = i;
                DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, Vector2.zero,
                    vanishingDuration).SetEase(vanishingCurve).SetDelay(vanishingDelay * i).SetId(1488);
            }

            _isVanishingByDistance = true;
            _isVanishing = false;
            
            ToggleTween();
        }

        [Button]
        public void VanishToNode()
        {
            KillTweens();
            //
            // _isVanishing = true;

            for (int i = 0; i < _spline.nodes.Count; i++)
            {
                var i1 = i;
                DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, Vector2.zero,
                    vanishingDuration).SetEase(vanishingCurve).SetDelay(vanishingDelay * i).SetId(1488);
            }
        }
        
        [Button]
        public void InverseVanish()
        {
            KillTweens();

            for (int i = _spline.nodes.Count - 1, p = 0; i >= 0; i--, p++)
            {
                var i1 = i;
                DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, Vector2.zero,
                    vanishingDuration).SetEase(vanishingCurve).SetDelay(vanishingDelay * p).SetId(1488);
            }
        }


        [Button]
        public void InterpolatePosDir()
        {
            DOTween.To(() => _spline.nodes[0].Position, x => _spline.nodes[0].Position = x, _endPos,
                interpolationDuration).SetId(1488);
            
            DOTween.To(() => _spline.nodes[0].Direction, x => _spline.nodes[0].Direction = x, _endDir,
                interpolationDuration).SetId(1488);
        }

        [Button]
        private void SaveScales()
        {
            initialScales.Clear();
            foreach (var n in _spline.nodes)
            {
                initialScales.Add(n.Scale);
            }
        }
        
        
        [Button]
        void KillTweens()
        {
            DOTween.Kill(1488);
        }
        
        public Vector3 GetGlobalNodePos(int nodeIdx) => _spline.transform.TransformPoint(_spline.nodes[nodeIdx].Position);

        public void RotateSegments(float rotationX, float rotationY)
        {
            foreach (var tr in _segmentTransforms)
            {
                tr.localRotation = Quaternion.Euler(rotationX, rotationY, 0);
            }
        }

        public void SetSegmentsRotationToZero()
        {
            foreach (var t in _segmentTransforms)
            {
                t.localRotation = Quaternion.identity;
            }
        }
        
        // [Button]
        // public void ResetScalingAndPositions()
        // {
        //     if (!_isScalesSaved)
        //     {
        //         _isScalesSaved = true;
        //         initialScales.Clear();
        //         foreach (var n in _spline.nodes)
        //         {
        //             initialScales.Add(n.Scale);
        //         }
        //     }
        //     
        //     
        //     _spline.nodes[0].Position = _nodeStartPos;
        //     _spline.nodes[0].Direction = _nodeStartDir;
        //
        //     for (int i = 0; i < initialScales.Count; i++)
        //     {
        //         _spline.nodes[i].Scale = initialScales[i];
        //     }
        // }

        public Material GetMeshMaterial()
        {
            var rends = GetComponentsInChildren<MeshRenderer>().Select(x => x.sharedMaterial);
            return rends.First();
        }

        [Button]
        public void SetIntensityToOne()
        {
            var mat = GetMeshMaterial();
            mat.SetColor("_TintColor", new Color(2.313f, 1.724f, 0.731f, 1.000f));
        }
        
        [Button]
        public void SetIntensityToZero()
        {
            var mat = GetMeshMaterial();
            mat.SetColor("_TintColor", new Color(0.5676508f, 0.4232598f, 0.1793991f, 1.000f));
        }
        
        
        
        private void CreateMeshes() 
        {
            if (!isCreatingEnabled)
            {
                return;
            }
#if UNITY_EDITOR
            // we don't update if we are in prefab mode
            if (UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage()) return;
#endif
            var used = new List<GameObject>();
            
            int i = 0;
            foreach (var curve in _spline.curves) 
            {
                var go = FindOrCreate("segment " + i++ + " mesh");
                go.GetComponent<MeshBender>().SetInterval(curve);
                used.Add(go);
            }

            // we destroy the unused objects. This is classic pooling to recycle game objects.
            foreach (var go in _generated.transform
                .Cast<Transform>()
                .Select(child => child.gameObject).Except(used).ToList()) 
            {
                UOUtility.Destroy(go);
            }

            _segmentTransforms = GetComponentsInChildren<MeshRenderer>().Select(x => x.transform).ToArray();
        }

        private GameObject FindOrCreate(string goName) 
        {
            var childTransform = _generated.transform.Find(goName);
            GameObject res;
            if (!childTransform) 
            {
                res = UOUtility.Create(goName,
                    _generated,
                    typeof(MeshFilter),
                    typeof(MeshRenderer),
                    typeof(MeshBender));
                res.isStatic = false;
            } 
            else 
            {
                res = childTransform.gameObject;
            }
            
            var meshRenderer = res.GetComponent<MeshRenderer>();
            meshRenderer.material = material;
            MeshBender mb = res.GetComponent<MeshBender>();
           
            mb.Source = SourceMesh.Build(mesh)
                .Translate(translation)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            mb.Mode = MeshBender.FillingMode.StretchToInterval;
            return res;
        }

        
        [Button]
        public void CalculateAndSetBoundingBoxVertices()
        {
            Vector3 min = Vector3.positiveInfinity;
            Vector3 max = Vector3.negativeInfinity;

            var splineMeshes = GetComponentsInChildren<MeshFilter>();
            
            foreach (MeshFilter meshFilter in splineMeshes)
            {
                if (meshFilter == null || meshFilter.sharedMesh == null)
                    continue;

                Vector3[] vertices = meshFilter.sharedMesh.vertices;
                for (int i = 0; i < vertices.Length; i++)
                {
                    Vector3 worldVertex = meshFilter.transform.TransformPoint(vertices[i]);
                    min = Vector3.Min(min, worldVertex);
                    max = Vector3.Max(max, worldVertex);
                }
            }

            Vector3 center = (min + max) * 0.5f;
            Vector3 size = max - min;

            BoxCollider boxCollider = gameObject.GetComponent<BoxCollider>();

            if (boxCollider == null)
            {
                boxCollider = gameObject.AddComponent<BoxCollider>();
            }

            boxCollider.center = transform.InverseTransformPoint(center);
            boxCollider.size = Vector3.one * centerBoxSize;
        }
    
        
        // private void ScaleSegment()
        // {
        //     if (!_startedThings)
        //     {
        //         _segmentsScales[0] = Vector2.one * startScale;
        //         _segmentsScales[1] = Vector2.one * ((startScale + endScale) / 2);
        //         _segmentsScales[2] = Vector2.one * endScale;
        //         _startedThings = true;
        //         _startTime = Time.realtimeSinceStartup;
        //     }
        //     
        //     var elapsedTime = Time.realtimeSinceStartup - _startTime;
        //
        //     var ts = new float[spline.nodes.Count];
        //
        //     for (int i = startNodeIdx; i < startNodeIdx + 3; i++)
        //     {
        //         var t = elapsedTime / scaleDuration;
        //
        //         if (i > startNodeIdx && ts[i - 1] > tThreshold)
        //         {
        //             t = ts[i - 1] - tThreshold;
        //             ts[i] = t;
        //         }
        //         else if (i > startNodeIdx && ts[i - 1] < tThreshold)
        //         {
        //             t = 0;
        //         }
        //         
        //         ts[i] = t;
        //
        //         if (scaleToZero && i != 2)
        //         {
        //             spline.nodes[i].Scale = Vector2.Lerp(Vector2.one * _segmentsScales[i - startNodeIdx], Vector2.zero, t);
        //         }
        //         else
        //         {
        //             spline.nodes[i].Scale = Vector2.Lerp(Vector2.zero, _segmentsScales[i - startNodeIdx], t);
        //         }
        //     }
        // }
        
        public Material[] GetSegmentMaterials()
        { 
            return GetComponentsInChildren<MeshRenderer>().Select(x => x.sharedMaterial).ToArray();
        }

        [Button]
        private void CenterMeshes()
        {
            foreach (var meshFilter in GetComponentsInChildren<MeshFilter>())
            {
                CenterMesh(meshFilter);
            }
        }
        
        private void CenterMesh(MeshFilter mf)
        {
            var meshToCenter = mf.sharedMesh;
            // Store the original world position
            Vector3 originalWorldPosition = mf.transform.position;

            // Calculate the current center in local space
            Vector3 localCenter = meshToCenter.bounds.center;

            // Calculate the current center in world space
            Vector3 worldCenter = mf.transform.TransformPoint(localCenter);

            Vector3[] vertices = meshToCenter.vertices;
            for (int i = 0; i < vertices.Length; i++)
            {
                vertices[i] -= localCenter;
            }
        

            meshToCenter.vertices = vertices;
            meshToCenter.RecalculateBounds();

            // Adjust the object's local position to compensate
            mf.transform.localPosition += mf.transform.InverseTransformVector(worldCenter - originalWorldPosition);
        }
    }
}
