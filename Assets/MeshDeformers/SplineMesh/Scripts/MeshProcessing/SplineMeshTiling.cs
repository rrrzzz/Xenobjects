using System.Collections;
using System.Collections.Generic;
using System.Linq;
using DG.Tweening;
using EasyButtons;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Serialization;


namespace SplineMesh 
{
    /// <summary>
    /// Deform a mesh and place it along a spline, given various parameters.
    /// 
    /// This class intend to cover the most common situations of mesh bending. It can be used as-is in your project,
    /// or can serve as a source of inspiration to write your own procedural generator.
    /// </summary>
    [ExecuteAlways]
    [SelectionBase]
    [DisallowMultipleComponent]
    public class SplineMeshTiling : MonoBehaviour 
    {
        [Tooltip("Mesh to bend along the spline.")]
        public Mesh mesh;
        [Tooltip("Material to apply on the bent mesh.")]
        public Material material;
        [Tooltip("Translation to apply on the mesh before bending it.")]
        public Vector3 translation;
        [Tooltip("Rotation to apply on the mesh before bending it.")]
        public Vector3 rotation;
        [Tooltip("Scale to apply on the mesh before bending it.")]
        public Vector3 scale = Vector3.one;

        // public int startNodeIdx;
        // public float startScale = 2.65f;
        // public float endScale = 0.05f;

        public float vanishingScaleThreshold;
        public float scaleToFullDuration = 1;
        public float scaleToZeroDuration = 1;
        public float vanishingDuration = 1;
        public float scaleToFullDelay = 0.1f;
        public float scaleToZeroDelay = 0.1f;
        public float vanishingDelay = 0.1f;
        [FormerlySerializedAs("scaleToFullCurve")]
        public AnimationCurve scaleCurve;
        public AnimationCurve vanishingCurve;
        public bool isInterpolating;
        public float interpolationDuration;
        public Vector3 nodeEndPos;
        public List<Vector2> initialScales = new List<Vector2>();
        
        public UnityEvent PathEndReachedEvent { get; } = new UnityEvent();

        private GameObject _generated;
        private Spline _spline;
        private bool _toUpdate;
        
        private Vector3 _orbScale;
        private bool _isScalesSaved;
        private Vector3 _nodeStartPos;
        private Vector3 _nodeStartDir;
        private Vector3 _nodeEndDir;
        private bool _isMinusNodePosNudge;
        private bool _isVanishing;
        private bool _isVanishingByDistance;
        private int _currentNodeToReach;
        private Transform _playerTr;
        private float _playerToPathNodeDistanceThreshold;

        private void OnEnable()
        {
            // tip : if you name all generated content in the same way, you can easily find all of it
            // at once in the scene view, with a single search.
            string generatedName = "generated by " + GetType().Name;
            var generatedTransform = transform.Find(generatedName);
            _generated = generatedTransform ? generatedTransform.gameObject : UOUtility.Create(generatedName, gameObject);
            
            _spline = GetComponentInParent<Spline>();
            _spline.NodeListChanged += (_, _) => _toUpdate = true;

            _toUpdate = true;
            
            ScaleToZeroNow();
            
            _nodeStartPos = _spline.nodes[0].Position;
            _nodeStartDir = _spline.nodes[0].Direction;
        }
        
        private void OnValidate() 
        {
            if (!_spline) return;
            _toUpdate = true;
        }

        [Button]
        public void ToggleTween()
        {
            DOTween.TogglePause(1488);
        }
        
        private void Update()
        {
            if (_isVanishingByDistance)
            {
                ResumeVanishingIfCloseToCurrentNode();
            }
            
            if (_isVanishing)
            {
                var currentScale = _spline.nodes[_currentNodeToReach].Scale.x;
                if (currentScale < vanishingScaleThreshold)
                {
                    DOTween.TogglePause(1488);
                    _isVanishing = false;
                }
            }
            
            if (!_toUpdate) return;
            
            _toUpdate = false;
            CreateMeshes();
        }
        
        private void ResumeVanishingIfCloseToCurrentNode()
        {
            var globalPos = GetGlobalNodePos(_currentNodeToReach);
            var distanceToNode = Vector3.Distance(globalPos, _playerTr.position);

            if (distanceToNode < _playerToPathNodeDistanceThreshold && !_isVanishing)
            {
                DOTween.TogglePause(1488);
                _currentNodeToReach++;
                if (_currentNodeToReach == _spline.nodes.Count)
                {
                    _isVanishingByDistance = false;
                    PathEndReachedEvent.Invoke();
                    return;
                }
                _isVanishing = true;
            }
        }
        

        [Button]
        private void SetAllNodeControlsToMirrored()
        {
            foreach (var node in _spline.nodes)
            {
                node.directionType = SplineNode.TangentType.Mirrored;
                node.Position += new Vector3(0, _isMinusNodePosNudge ? -0.001f : 0.001f, 0);
            }

            _isMinusNodePosNudge = !_isMinusNodePosNudge;
        }
        
        [Button]
        public void ScaleToFullNow()
        {
            for (int i = 0; i < _spline.nodes.Count; i++)
            {
                _spline.nodes[i].Scale = initialScales[i];
            }
        }
        
        [Button]
        public void ScaleToFull()
        {
            ScaleSpline(true);
        }
        
        [Button]
        public void ScaleToZeroNow()
        {
            foreach (var node in _spline.nodes)
            {
                node.Scale = Vector2.zero;
            }
        }
        
        [Button]
        public void ScaleToZero()
        {
            ScaleSpline(false);
        }

        public float GetTotalScaleToFullDuration()
        {
            return scaleToFullDuration + scaleToFullDelay * _spline.nodes.Count;
        }
        
        public float GetTotalScaleToZeroDuration()
        {
            return scaleToZeroDuration + scaleToFullDelay * _spline.nodes.Count;
        }
        
        public void ScaleSpline(bool scaleToFull)
        {
            foreach (var t in _spline.nodes)
            {
                if (scaleToFull)
                {
                    t.Scale = Vector2.zero;
                }
            }
            
            for (int i = 0; i < _spline.nodes.Count; i++)
            {
                var i1 = i;
                
                if (scaleToFull)
                {
                    DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, initialScales[i1],
                        scaleToFullDuration).SetEase(scaleCurve).SetDelay(scaleToFullDelay * i).SetId(1488); 
                }
                else
                {
                    {
                        DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, Vector2.zero,
                                scaleToZeroDuration)
                            .SetEase(scaleCurve).SetDelay(scaleToZeroDelay * i).SetId(1488);
                    }
                }
            }
        }

        // [Button]
        public void InitVanishing(Transform playerTransform, float playerToPathNodeDistanceThreshold)
        {
            _playerTr = playerTransform;
            _playerToPathNodeDistanceThreshold = playerToPathNodeDistanceThreshold;
            _currentNodeToReach = 0;

            for (int i = 0; i < _spline.nodes.Count; i++)
            {
                var i1 = i;
                DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, Vector2.zero,
                    vanishingDuration).SetEase(vanishingCurve).SetDelay(vanishingDelay * i).SetId(1488);
            }

            _isVanishingByDistance = true;
            _isVanishing = false;
            
            ToggleTween();
        }

        [Button]
        public void VanishToNode()
        {
            KillTweens();
            //
            // _isVanishing = true;

            for (int i = 0; i < _spline.nodes.Count; i++)
            {
                var i1 = i;
                //TODO: Remove in final version
                _spline.nodes[i1].Scale = initialScales[i1];
                DOTween.To(() => _spline.nodes[i1].Scale, x => _spline.nodes[i1].Scale = x, Vector2.zero,
                    vanishingDuration).SetEase(vanishingCurve).SetDelay(vanishingDelay * i).SetId(1488);
            }
        }
        
        // [Button]
        private void SaveStartDirPos()
        {
            _nodeStartPos = _spline.nodes[0].Position;
            _nodeStartDir = _spline.nodes[0].Direction;
        }
        
        // [Button]
        private void SaveEndDirPos()
        {
            nodeEndPos = _spline.nodes[0].Position;
            _nodeEndDir = _spline.nodes[0].Direction;
        }

        // [Button]
        private void InterpolatePosDir()
        {
            DOTween.To(() => _spline.nodes[0].Position, x => _spline.nodes[0].Position = x, nodeEndPos,
                interpolationDuration).SetId(1488);
            
            DOTween.To(() => _spline.nodes[0].Direction, x => _spline.nodes[0].Direction = x, _nodeEndDir,
                interpolationDuration).SetId(1488);
        }

        [Button]
        private void SaveScales()
        {
            initialScales.Clear();
            foreach (var n in _spline.nodes)
            {
                initialScales.Add(n.Scale);
            }
        }
        
        
        [Button]
        void KillTweens()
        {
            DOTween.Kill(1488);
        }
        
        public Vector3 GetGlobalNodePos(int nodeIdx) => _spline.transform.TransformPoint(_spline.nodes[nodeIdx].Position);

        
        // [Button]
        // public void ResetScalingAndPositions()
        // {
        //     if (!_isScalesSaved)
        //     {
        //         _isScalesSaved = true;
        //         initialScales.Clear();
        //         foreach (var n in _spline.nodes)
        //         {
        //             initialScales.Add(n.Scale);
        //         }
        //     }
        //     
        //     
        //     _spline.nodes[0].Position = _nodeStartPos;
        //     _spline.nodes[0].Direction = _nodeStartDir;
        //
        //     for (int i = 0; i < initialScales.Count; i++)
        //     {
        //         _spline.nodes[i].Scale = initialScales[i];
        //     }
        // }

        private void CreateMeshes() 
        {
#if UNITY_EDITOR
            // we don't update if we are in prefab mode
            if (UnityEditor.SceneManagement.PrefabStageUtility.GetCurrentPrefabStage()) return;
#endif
            var used = new List<GameObject>();

            
            int i = 0;
            foreach (var curve in _spline.curves) 
            {
                var go = FindOrCreate("segment " + i++ + " mesh");
                go.GetComponent<MeshBender>().SetInterval(curve);
                used.Add(go);
            }

            // we destroy the unused objects. This is classic pooling to recycle game objects.
            foreach (var go in _generated.transform
                .Cast<Transform>()
                .Select(child => child.gameObject).Except(used).ToList()) 
            {
                UOUtility.Destroy(go);
            }
        }

        private GameObject FindOrCreate(string goName) 
        {
            var childTransform = _generated.transform.Find(goName);
            GameObject res;
            if (!childTransform) 
            {
                res = UOUtility.Create(goName,
                    _generated,
                    typeof(MeshFilter),
                    typeof(MeshRenderer),
                    typeof(MeshBender));
                res.isStatic = false;
            } 
            else 
            {
                res = childTransform.gameObject;
            }
            
            var meshRenderer = res.GetComponent<MeshRenderer>();
            meshRenderer.material = material;
            MeshBender mb = res.GetComponent<MeshBender>();
           
            mb.Source = SourceMesh.Build(mesh)
                .Translate(translation)
                .Rotate(Quaternion.Euler(rotation))
                .Scale(scale);
            mb.Mode = MeshBender.FillingMode.StretchToInterval;
            return res;
        }
        
        // private void ScaleSegment()
        // {
        //     if (!_startedThings)
        //     {
        //         _segmentsScales[0] = Vector2.one * startScale;
        //         _segmentsScales[1] = Vector2.one * ((startScale + endScale) / 2);
        //         _segmentsScales[2] = Vector2.one * endScale;
        //         _startedThings = true;
        //         _startTime = Time.realtimeSinceStartup;
        //     }
        //     
        //     var elapsedTime = Time.realtimeSinceStartup - _startTime;
        //
        //     var ts = new float[spline.nodes.Count];
        //
        //     for (int i = startNodeIdx; i < startNodeIdx + 3; i++)
        //     {
        //         var t = elapsedTime / scaleDuration;
        //
        //         if (i > startNodeIdx && ts[i - 1] > tThreshold)
        //         {
        //             t = ts[i - 1] - tThreshold;
        //             ts[i] = t;
        //         }
        //         else if (i > startNodeIdx && ts[i - 1] < tThreshold)
        //         {
        //             t = 0;
        //         }
        //         
        //         ts[i] = t;
        //
        //         if (scaleToZero && i != 2)
        //         {
        //             spline.nodes[i].Scale = Vector2.Lerp(Vector2.one * _segmentsScales[i - startNodeIdx], Vector2.zero, t);
        //         }
        //         else
        //         {
        //             spline.nodes[i].Scale = Vector2.Lerp(Vector2.zero, _segmentsScales[i - startNodeIdx], t);
        //         }
        //     }
        // }
    }
}
